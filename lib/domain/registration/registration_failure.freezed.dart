// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'registration_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$RegistrationFailureTearOff {
  const _$RegistrationFailureTearOff();

// ignore: unused_element
  UnableToWriteDB unableToWriteDB() {
    return const UnableToWriteDB();
  }

// ignore: unused_element
  MatchesAlreadyRegistered matchesAlreadyRegistered() {
    return const MatchesAlreadyRegistered();
  }
}

// ignore: unused_element
const $RegistrationFailure = _$RegistrationFailureTearOff();

mixin _$RegistrationFailure {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unableToWriteDB(),
    @required Result matchesAlreadyRegistered(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unableToWriteDB(),
    Result matchesAlreadyRegistered(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unableToWriteDB(UnableToWriteDB value),
    @required Result matchesAlreadyRegistered(MatchesAlreadyRegistered value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unableToWriteDB(UnableToWriteDB value),
    Result matchesAlreadyRegistered(MatchesAlreadyRegistered value),
    @required Result orElse(),
  });
}

abstract class $RegistrationFailureCopyWith<$Res> {
  factory $RegistrationFailureCopyWith(
          RegistrationFailure value, $Res Function(RegistrationFailure) then) =
      _$RegistrationFailureCopyWithImpl<$Res>;
}

class _$RegistrationFailureCopyWithImpl<$Res>
    implements $RegistrationFailureCopyWith<$Res> {
  _$RegistrationFailureCopyWithImpl(this._value, this._then);

  final RegistrationFailure _value;
  // ignore: unused_field
  final $Res Function(RegistrationFailure) _then;
}

abstract class $UnableToWriteDBCopyWith<$Res> {
  factory $UnableToWriteDBCopyWith(
          UnableToWriteDB value, $Res Function(UnableToWriteDB) then) =
      _$UnableToWriteDBCopyWithImpl<$Res>;
}

class _$UnableToWriteDBCopyWithImpl<$Res>
    extends _$RegistrationFailureCopyWithImpl<$Res>
    implements $UnableToWriteDBCopyWith<$Res> {
  _$UnableToWriteDBCopyWithImpl(
      UnableToWriteDB _value, $Res Function(UnableToWriteDB) _then)
      : super(_value, (v) => _then(v as UnableToWriteDB));

  @override
  UnableToWriteDB get _value => super._value as UnableToWriteDB;
}

class _$UnableToWriteDB implements UnableToWriteDB {
  const _$UnableToWriteDB();

  @override
  String toString() {
    return 'RegistrationFailure.unableToWriteDB()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnableToWriteDB);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unableToWriteDB(),
    @required Result matchesAlreadyRegistered(),
  }) {
    assert(unableToWriteDB != null);
    assert(matchesAlreadyRegistered != null);
    return unableToWriteDB();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unableToWriteDB(),
    Result matchesAlreadyRegistered(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unableToWriteDB != null) {
      return unableToWriteDB();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unableToWriteDB(UnableToWriteDB value),
    @required Result matchesAlreadyRegistered(MatchesAlreadyRegistered value),
  }) {
    assert(unableToWriteDB != null);
    assert(matchesAlreadyRegistered != null);
    return unableToWriteDB(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unableToWriteDB(UnableToWriteDB value),
    Result matchesAlreadyRegistered(MatchesAlreadyRegistered value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unableToWriteDB != null) {
      return unableToWriteDB(this);
    }
    return orElse();
  }
}

abstract class UnableToWriteDB implements RegistrationFailure {
  const factory UnableToWriteDB() = _$UnableToWriteDB;
}

abstract class $MatchesAlreadyRegisteredCopyWith<$Res> {
  factory $MatchesAlreadyRegisteredCopyWith(MatchesAlreadyRegistered value,
          $Res Function(MatchesAlreadyRegistered) then) =
      _$MatchesAlreadyRegisteredCopyWithImpl<$Res>;
}

class _$MatchesAlreadyRegisteredCopyWithImpl<$Res>
    extends _$RegistrationFailureCopyWithImpl<$Res>
    implements $MatchesAlreadyRegisteredCopyWith<$Res> {
  _$MatchesAlreadyRegisteredCopyWithImpl(MatchesAlreadyRegistered _value,
      $Res Function(MatchesAlreadyRegistered) _then)
      : super(_value, (v) => _then(v as MatchesAlreadyRegistered));

  @override
  MatchesAlreadyRegistered get _value =>
      super._value as MatchesAlreadyRegistered;
}

class _$MatchesAlreadyRegistered implements MatchesAlreadyRegistered {
  const _$MatchesAlreadyRegistered();

  @override
  String toString() {
    return 'RegistrationFailure.matchesAlreadyRegistered()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is MatchesAlreadyRegistered);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result unableToWriteDB(),
    @required Result matchesAlreadyRegistered(),
  }) {
    assert(unableToWriteDB != null);
    assert(matchesAlreadyRegistered != null);
    return matchesAlreadyRegistered();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result unableToWriteDB(),
    Result matchesAlreadyRegistered(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (matchesAlreadyRegistered != null) {
      return matchesAlreadyRegistered();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result unableToWriteDB(UnableToWriteDB value),
    @required Result matchesAlreadyRegistered(MatchesAlreadyRegistered value),
  }) {
    assert(unableToWriteDB != null);
    assert(matchesAlreadyRegistered != null);
    return matchesAlreadyRegistered(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result unableToWriteDB(UnableToWriteDB value),
    Result matchesAlreadyRegistered(MatchesAlreadyRegistered value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (matchesAlreadyRegistered != null) {
      return matchesAlreadyRegistered(this);
    }
    return orElse();
  }
}

abstract class MatchesAlreadyRegistered implements RegistrationFailure {
  const factory MatchesAlreadyRegistered() = _$MatchesAlreadyRegistered;
}
